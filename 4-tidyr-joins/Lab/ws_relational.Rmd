# Relational Data with `dplyr`   

It is rare that ecological data analyses involve only a single table of data. 
More typically, you have multiple tables of data, describing different aspects 
of your study. When you embark on analyzing your data, these different data 
tables need to be combined. Collectively, multiple tables of data are called 
*relational data*, as the data tables are not independent, rather they relate to
each other. 

Relations are defined between a pair of data tables. There are three families of
joining operations: mutating joins, filtering joins, and set operations. Today 
we will focus on mutating joins. 

The `survey` data have two other data tables they are related to: `plots` and 
`species`. Load in these data and inspect them to get an idea of how they relate
to the `survey` data we've been working with. 

</br>

```{r, purl = TRUE, message = FALSE}
plots <- read_csv("data/plots.csv")

species <- read_csv("data/species.csv")

```

</br>

The variables used to connect a pair of tables are called *keys*. A key is a 
variable that uniquely identifies an observation in that table.  What are the 
keys for each of the three data tables? (hint: What combination of variables 
uniquely identifies a row in that data frame?) 

- plots key:  

- species key:  

- surveys key: 


There are two types of keys:  

- A *primary key* uniquely identifies an observation in its own table.  
- A *foreign key* uniquely identifies an observation in another table.  

A primary key and the corresponding foreign key form a *relation* between the 
two data tables. These relations are typically many-to-one, though they can be 
1-to-1. For example, there are many rodents captured that are of one species_id,
hence a many-to-one relationship.  

For me, the easiest way to think about the relationships between the different 
data tables is to draw a picture:  

![Relations of survey data tables](figures/relations.jpg)


\pagebreak 

## Joining Relational Data  

The tool that we will be using is called a *mutating join*. A mutating join is 
how we can combine variables from two tables. The join matches observations by 
their keys, and then copies variables from one table to the other. Similar to 
`mutate()` these join functions add variables to the right of the existing data 
frame, hence their name. There are two types of mutating joins, the inner join 
and the outer join.    

## Inner Join 

The simplest join is an *inner join*, which creates a pair of observations 
whenever their keys are equal. This join will output a new data frame that 
contains the key, the values of `x`, and the values of `y`. Importantly, this 
join deletes observations that do not have a match. 

\begin{figure}[h!]
\caption{Wickham, H. \& Grolemund, G. (2017) \emph{R for Data Science}. 
Sebastopol, California: O'Reilly.}
\includegraphics{figures/inner.jpg}
\centering
\end{figure}

## Outer Join  

While an inner join only keeps observations with keys that appear in both 
tables, an *outer join* keeps observations that appear in *at least one* of the 
data tables. When joining `x` with `y`, there are three types of outer join:  

- A *left join* keeps all of the observations in `x`.   
- A *right join* keeps all of the observations in `y`.  
- A *full join* keeps all of the observations in both `x` and `y`. 

\begin{figure}[h!]
\caption{Wickham, H. \& Grolemund, G. (2017) \emph{R for Data Science}. 
Sebastopol, California: O'Reilly.}
\includegraphics{figures/joins.jpg}
\centering
\end{figure}


The left join is the most common, as you typically have a data frame (`x`) that 
you wish to add additional information to (the contents of `y`). This join will 
preserve the contents of `x`, even if there is not a match for them in `y`. 

\pagebreak 

## Joining `survey` Data  

To join the `survey` data with the `plots` data and `species` data, we will need
to join statements. As we are interested in adding this information to our 
already existing data frame, `surveys`, a left join is the most appropriate.  

</br>

```{r, purl = TRUE, warning = FALSE}

combined <- surveys %>% 
              left_join(plots, by = "plot_id") %>%  # adding the type of plot  
              left_join(species, by = "species_id") # adding the genus, species, and taxa 

glimpse(combined)
```

\pagebreak 

# Reshaping with `pivot_longer()` and `pivot_wider()`

Data Carpentry's [spreadsheet
lesson (link)](https://datacarpentry.org/spreadsheet-ecology-lesson/01-format-data/),
discusses how to structure our data leading to the four rules defining a tidy
dataset:

1. Each variable has its own column
2. Each observation has its own row
3. Each value must have its own cell
4. Each type of observational unit forms a table

![](figures/tidy-data.png)