---
title: "Final Exam - First Half"
author: 'Stat 331: Winter 2022'
output: rmdformats::readthedown
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      eval = FALSE, 
                      message = FALSE, 
                      warning = FALSE)
```

```{r, eval = TRUE, include = FALSE}
library(tidyverse)
library(infer)
library(palmerpenguins)
```

```{r, eval = TRUE}
np_trails <- read_csv(here::here("11_Final", 
                                 "national_park_trails.csv"))
```

## Introduction

This exam is due by **10:00am** on **Wednesday, March 16th**.
Late exams will receive a grade of 0. 
**Please do not turn your exam in late!!!**

Please create a new R Markdown file for parts two and three of this exam.
Make sure your files are set up to display **all** your source code when
knitted.

Clearly mark the questions, so that I can easily find your answers to grade them.
Please **DO NOT** use nonstandard R Markdown templates for any portion of this
exam.

Although you are not directly graded on data exploration, cleaning, and
adjusting, you will certainly need to do this to properly address the questions.

### Policies

  * You may use: any online resources, including anything posted on Canvas. 
  * You may NOT contact anyone, inside or outside this class, during the course
  of the exam.  This includes email, chat/messenger services, and posting on
  online forums and message boards.
  * You may NOT use exam materials from previous years.
  * Violations of academic honesty include accessing and using any illegal
  materials, and giving or receiving help on this exam including looking at
  other student's exams, allowing other students to look at your own exam, 
  and/or revealing any information about this exam or future exams to someone
  who has not yet taken it.
  * Students who exhibit academic misconduct will be reported to the Office of
  Student Rights and Responsibilities; academic dishonesty may be punishable by
  a grade of F in this course.
  * You may **not** discuss the exam with any other students until after the
  exams have been returned to all students.
  * If you witness others exhibiting academic misconduct, you have a duty to
  report them to your professor.

### Instructions

  * Please note that you will need to use the data description in order to
  successfully complete this exam.
  * The problems on this exam do not necessarily need to be completed
  sequentially, e.g., if you cannot accomplish problem 1, you may still be able
  to accomplish problem 2.
  * Some parts to problems may need to be completed sequentially. If you cannot
  complete part (a), please outline code or your thought process for completing
  part (b).
  * All questions should be answered **using R code**.  Make sure your code
  prints out only the information that directly answers the question.  
  **Penalties will be given if your `.html` file has extra output beyond that
  which answers the question.**
  * If your code has errors that you cannot fix in time, you may also include in
  the comments explanations of your thought process, to potentially receive
  partial credit.
  * Submit both your `.Rmd` and `.html` files on Canvas by the end of the
  allotted time. However, only your `.html` file will be graded - make sure the
  knitted output contains all your answers.
  
</br>

---

</br>

## Part One: Functions & Iteration  [50 points]

<center>
### This portion of the exam should take you approximately 30-45 minutes.
</center>


__1.__ Taylor is interested in writing a function that handles the various ways 
missing values are coded by different researchers. Taylor has found three 
ways `NA` values are coded by researchers in her field for character vectors:
`"."`, `""`, and `"NaN"`. Taylor would like to write a function that handles all
of these cases. 

Consider the following function skeleton: 

```{r, echo = TRUE}
na_function <- function(x){
  case_when(x == "." ~ ____, 
            x == "" ~ ____, 
            x == "NaN" ~ ____)
}
```

```{r, eval = TRUE}
na_function <- function(x){
  case_when(x == "." ~ NA_character_, 
            x == "" ~ NA_character_, 
            x == "NaN" ~ NA_character_, 
            TRUE ~ x)
}
```


__(a)__ What should Taylor insert as the values after each `~` 
(in place of the `____`)?

- `NA`
- `NA_real_`
- `NA_character_`  
- `"NA"`

__(b)__ Currently, this function converts every value of the character vector
into an `NA`. What is missing from the function that will return the value of
`x`, if `x` is not equal to `"."`, `""`, or `"NaN"`? 

**Your response should be _one_ line of code!**

</br> 

__2.__ Taylor would like to write a new function `df_na()` that takes a dataframe
and a variable as inputs, and uses the `na_function()` to replace the values
for the variable input. Additionally, Taylor envisions using either 
`df_na(dataset, "variable")` or `df_na(dataset, variable)` as the input 
to the function. 

Which of the following functions will correctly carry out this process? The
function can either return the dataframe with the variable adjusted ***or*** a 
vector with the adjusted variable.

**Select all that apply**

__(a)__
```{r, echo = TRUE}
df_na <- function(df, vars){
  df %>% 
    mutate(var = na_function(vars))
}
```

__(b)__
```{r, echo = TRUE}
df_na <- function(df, vars){
  na_function(df[vars])
}
```

__(c)__
```{r, echo = TRUE, eval = TRUE}
df_na <- function(df, vars){
  df %>% 
    mutate(
      across(.cols = {{vars}},
             .fns = na_function
             )
           )
}
```

__(d)__
```{r, echo = TRUE}
df_na <- function(df, vars){
  na_function(df[[vars]])
}
```

</br>

__3.__ Taylor has chosen to use one of the `df_na()` functions above that
returns a dataframe with the character variables adjusted. Taylor now wants to
use her function to clean up an example dataset. Taylor decides to use the `mpg`
dataset (from the **tidyverse**) to  test out these functions. 

Taylor knows that it is better to use `map()` functions to do repeated
operations, but isn't sure why her code isn't working. 

```{r, echo = TRUE, eval = TRUE, error = TRUE}
mpg %>% 
  map_dfc(c(manufacturer, model, trans, drv), df_na)
```

Which of the following are reasons for the above code returning an error?

**Select all that apply**

__(a)__ `map_chr()` should be used instead of `map_dfc()`

__(b)__ `df_na()` takes two inputs and it is only being supplied one input

__(c)__ `across()` is not correctly selecting the variables

__(d)__ `map()` functions work with vectors, not dataframes

</br>

__4.__ Which of the following methods could Taylor use to replace the missing 
values of the character variables in the `mpg` dataset? 

**Select all that apply**

__(a)__ 

```{r, echo = TRUE}
mpg %>% 
  mutate(
    across(.cols = where(is.character), 
           .fns = df_na)
  )
```

__(b)__

```{r, echo = TRUE}
mpg %>% 
  df_na(vars = c(manufacturer, model, trans, drv))
```

__(c)__

```{r, echo = TRUE}
mpg %>% 
  mutate(
    across(.cols = c(manufacturer, model, trans, drv), 
           .fns = na_function
           )
  )
```


__(d)__

```{r, echo = TRUE}
penguins %>% 
  mutate(
    across(.cols = everything(), 
           .fns = ~df_na(df = .)
           )
  )
```

</br>

---

</br>

## Part Two: Short answer questions [100 points]

<center>
### This portion of the exam should take you approximately 60-90 minutes.
</center>

### The Data

National parks were a big part of my childhood, with lots of family trips around 
the US. National parks offer a great respite from the busyness of life, but are 
often overwhelming in the number and variety of trails you can hike on! For this
portion of the exam you will summarize some characteristics of the trails at a 
variety of national parks, using data contributed from users of AllTrails. 

The dataset was taken from the *AllTrails* app, which allows users to input
new trails and rate existing ones.
You can find documentation on the dataset from its creator 
[here](https://www.kaggle.com/planejane/national-park-trails).

Variables in the data are:

* `trail_id`: An ID number for the trail
* `name`: Name of the trail
* `area_name`: National Park where the trial is located
* `city_name`: City where the trail is located
* `state_name`: State where the trail is located
* `country_name`: Country where the trail is located
* `_geoloc`: Latitude and longitude of trail
* `popularity`: A score from 0 to 100 of how often the trail is used.
* `length`: Distance covered by trail (**in meters**).
* `elevation_gain`: How much uphill is on the trail (in meters).
* `difficulty_rating`: Average user rating of trail difficulty
* `route_type`: Type of trail (loop, out and back, or point to point)
* `visitor_usage`: (Honestly, I'm not sure what this one is.)
* `avg_rating`: The average visitor rating of the trail (1 to 5 stars)
* `num_reviews`: The total number of reviews on the app for that trail
* `features`: Notable elements about the trail
* `activities`: Common uses for the trail
* `units`: **This variable is a lie!** All the lengths are in meters.


Answer each of the following using code. The output of the code should clearly 
and directly answer the question.  You do not need to provide any text answers;
only code and output.  For example, if the question is, "What is the longest
bill length of any penguin in the dataset?", you might provide:

```{r, echo = TRUE, eval = TRUE}
library(palmerpenguins)

penguins %>% 
  slice_max(n = 1, bill_length_mm) %>%
  pull(bill_length_mm)
```

#### Question 1.1  [10 points]

Which National Park contains the most trails with a 5-star average rating?

```{r}
np_trails %>%
  filter(avg_rating == 5) %>%
  count(area_name) %>%
  slice_max(n = 1, n)
```


#### Question 1.2 [10 points]

What are the three longest trails in this dataset, in miles?

```{r}
np_trails %>%
  mutate(
    length_miles = length*3.28/5280
  ) %>%
  slice_max(n = 3, length_miles) %>%
  select(name, area_name, length_miles)
```

#### Question 1.3 [10 points]

What is the most popular trail in each National Park?

```{r}
np_trails %>%
  group_by(area_name) %>%
  slice_max(popularity) %>% 
  select(name, area_name)
```



#### Question 1.4 [10 points]

How many National Parks contain the word "Canyon" somewhere in their name?

```{r}
np_trails %>%
  distinct(area_name) %>%
  pull(area_name) %>%
  str_detect("[Cc]anyon") %>%
  sum()
```

#### Question 1.5 [20 points]

What are the five common words used in trail names?

Do not include besides words that mean "trail", like "trail", "route", "path",
"loop".

Do not include connector words like "to", "and", "with", "via", etc.

```{r}
trail_words <- np_trails %>%
  pull(name) %>%
  str_extract_all("\\w+") %>%
  unlist() 

word_counts <- tibble(
  word = trail_words) %>%
  count(word, sort = TRUE)

# Lake
# Creek
# Mountain
# Falls
# Canyon
```

#### Question 1.6 [20 points]

Write a function that takes two **required** inputs: 

* the dataset
* the name of a National Park

Your function should also accept the following **optional** arguments:

* A minimum trail length (in miles)
* A maximum trail length (in miles)
* A minimum trail rating
* The type of trail (out and back, loop, or point to point)

The function should return all the trails that fit the supplied criteria. You
**may** assume that the variable names of the inputted dataset match the
`np_trails` dataset.

Include the following code in your response to verify that your function works:

```{r}
recommend_trails <- function(data, park_name, min_len_mi = 0, 
                             max_len_mi = Inf, min_rating = 0, type = NULL) {
  
  if (!is.null(type)) {
    data <- data %>%
      filter(route_type == type)
  }
  
  trails <- data %>%
    mutate(
      length = length*3.3/5280
    ) %>%
    filter(
      area_name == park_name,
      length > min_len_mi,
      length < max_len_mi,
      avg_rating > min_rating
    )
  
  return(trails)
  
}
```


```{r, echo = TRUE}
np_trails %>%
  recommend_trails("Yellowstone National Park", 
                   min_len_mi = 10, 
                   min_rating = 4, 
                   type = "loop")
```


#### Question 1.7 [20 points]

Use your function from Question 1.6, along with a `map()` or `apply()` function
to recommend to me all the trails that are:

- 20-30  miles long  (good for a two day backpacking trip!)

- Rated at least a 4.5

- Loop trails (I don't like to retrace my steps)

- In one of the parks closest to my hometown: 

    * Arches National Park
    * Canyonlands National Park
    * Rocky Mountain National Park
    * Zion National Park
    * Bryce National Park
    * Mesa Verde National Park
    * Black Canyon of the Gunnison National Park


    <!-- * Sequoia National Park -->
    <!-- * Joshua Tree National Park -->
    <!-- * Lassen Volcanic National Park -->
    <!-- * Kings Canyon National Park -->
    <!-- * Pinnacles National Park -->
    <!-- * Death Valley National Park -->
    <!-- * Redwood National Park  -->

```{r}
parks <- c("Sequoia National Park",
           "Joshua Tree National Park",
           "Lassen Volcanic National Park",
           "Kings Canyon National Park",
           "Death Valley National Park",
           "Redwood National Park")

map_dfr(parks, ~recommend_trails(np_trails, .x, 
                                 min_len = 20, 
                                 max_len = 40, 
                                 min_rating = 4.5,
                                 type = "loop"))
```

