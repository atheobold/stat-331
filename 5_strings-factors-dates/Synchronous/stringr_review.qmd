---
title: "STAT 331"
title-slide-attributes:
    data-background-image: images/stringr_horst.png
    data-background-size: contain
    data-background-opacity: "0.5"
format: 
  revealjs:
    self-contained: true
    auto-stretch: false
editor: visual
execute: 
  echo: false
---

```{r setup}
#| include: false
#| message: false
library(tidyverse)
library(palmerpenguins)

# cereal data
library(liver)
data(cereal)
```

## strings

A **string** is a bunch of **characters**.

Don't confuse a **string** (many characters, one object) with a **character vector** (vector of strings).

<br>

```{r}
#| echo: true
my_string <- "Hi, my name is Bond!"
my_vector <- c("Hi", "my", "name", "is", "Bond")
```

<br>

```{r}
#| echo: true
my_string
```

<br>

```{r}
#| echo: true
my_vector
```

# `stringr`

::: columns
::: column
**Common tasks**

-   Find which strings contain a particular pattern

-   Remove or replace a pattern

-   Edit a string (for example, make it lowercase)
:::

::: column
```{r}
#| fig-align: center
#| out-width: 40%
knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/PNG/stringr.png?raw=true")
```
:::
:::

::: callout-note
The package `stringr` is very useful for strings!

-   `stringr` **does** load with the `tidyverse`.

-   all the functions are `str_xxx()`.
:::

## `pattern =`

The **pattern argument** in all of the `stringr` functions ...

```{r}
#| eval: false
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")

str_detect(my_vector, pattern = "Bond")
str_locate(my_vector, pattern = "Bond")
str_match(my_vector, pattern = "Bond")
str_extract(my_vector, pattern = "Bond")
str_subset(my_vector, "pattern = Bond")
```

::: callout-note
Discuss with a neighbor. For each of these functions, give:

-   The **object structure** of the output.
-   The **data type** of the output.
-   A brief explanation of what they do.
:::

## `str_detect()`

Returns **logical vector** `TRUE/FALSE` indicating if the pattern was found in that element of the original vector

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_detect(my_vector, pattern = "Bond")
```

</br>

. . .

-   Pairs well with `filter()`
-   Could be used with `summarise()` and `sum()` or `mean()`

::: {.callout-note collapse="true"}
### Related functions

`str_subset()` returns just the strings that contain the match

`str_which()` returns the indexes of strings that have a match
:::

## `str_match()`

Returns **character matrix** with either `NA` or the pattern, depending on if the pattern was found.

</br>

```{r}
#| echo: true
#| code-line-numbers: false

my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_match(my_vector, pattern = "Bond")
```

## `str_extract()`

Returns **character vector** with either `NA` or the *pattern*, depending on if the pattern was found.

</br>

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_extract(my_vector, pattern = "Bond")
```

. . .

</br>

::: callout-warning
`str_extract()` only returns the **first** pattern match.

Use `str_extract_all()` to return **every** pattern match.
:::

## `str_locate()`

Returns a **date frame** with two **numeric variables** for the starting and ending location, giving either `NA` or the start and end position of the pattern.

</br>

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_locate(my_vector, pattern = "Bond")
```

## `str_subset()`

Returns a **character vector** with a subset of the original **character vector** with elements where the pattern occurs.

</br>

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_subset(my_vector, pattern = "Bond")
```

</br>

::: callout-note
### Related Functions

`str_sub()` extracts values based on location (starting and ending position).
:::

## Replace / Remove patterns

::: panel-tabset
### `str_replace()`

::: {style="font-size: 0.75em"}
Replaces the [first]{.underline} matched pattern

-   Pairs well with `mutate()`
:::

</br>

```{r}
#| echo: true
#| code-line-numbers: false
str_replace(my_vector, pattern = "Bond", replace = "Franco")
```

### `str_remove()`

::: {style="font-size: 0.75em"}
Removes the [first]{.underline} matched pattern

-   You could think of `str_remove()` as a special case of `str_replace( )`, where the `replace` argument is empty (`""`).
:::

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_remove(my_vector, pattern = "Bond")
```
:::

::: {.callout-note collapse="true"}
### Related functions

`str_replace_all()` replaces **all** matched patterns

`str_remove_all()` removes **all** matched patterns
:::

## Make edits

::: {style="font-size: 0.75em"}
Convert letters in the string to a specific capitalization format.
:::

::: panel-tabset
### `str_to_lower()`

::: {style="font-size: 0.75em"}
converts all letters in the strings to lowercase
:::

<br>

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_to_lower(my_vector)
```

### `str_to_upper()`

::: {style="font-size: 0.75em"}
converts all letters in the strings to uppercase
:::

```{r}
#| echo: true
#| code-line-numbers: false

str_to_upper(my_vector)
```

### `str_to_title()`

::: {style="font-size: 0.75em"}
converts the first letter of the strings to uppercase
:::

```{r}
#| echo: true
#| code-line-numbers: false
str_to_title(my_vector)
```
:::

## Combine Strings

::: panel-tabset
### `str_c()`

::: {style="font-size: 0.75em"}
Joins multiple strings into a single string

-   `sep` argument declares how the strings should be separated when pasting
:::

```{r}
#| echo: true
#| code-line-numbers: false
prompt <- "Hello, my name is"
first  <- "James"
last   <- "Bond"
str_c(prompt, last, ",", first, last, sep = " ")
```

::: callout-note
Similar to `paste()` and `paste0()`
:::

### `str_flatten()`

::: {style="font-size: 0.75em"}
Combines into a single string.
:::

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_flatten(my_vector, collapse = " ")
```

::: callout-note
`str_c()` and `glue()` work well with `mutate()` -- their output is the same length as their inputs. 
`str_flatten()` works well with `summarise()` -- it always returns a single string! 
:::

### `str_glue()`

::: {style="font-size: 0.75em"}
Uses environment to create a string and evaluates {expressions}.
:::

```{r}
#| echo: true
#| code-line-numbers: false
first <- "James"
last <- "Bond"
str_glue("My name is {last}, {first} {last}")
```

::: callout-tip
We will use the **glue** package *a lot* in Week 7!
:::
:::

## Tips for Success

-   Refer to the [`stringr` cheatsheet](https://posit.co/wp-content/uploads/2022/10/strings-1.pdf)

-   Remember that `str_xxx` functions need the first argument to be a **vector of strings**, not a **data set**.

    -   You might want to use them *inside* functions like `filter()` or `mutate()`.

```{r}
#| echo: true
cereal |> 
  mutate(
    is_bran = str_detect(name, "Bran"), 
    .after = name
  )
```

# regex

```{r}
#| fig-align: center
#| out-width: 70%
knitr::include_graphics("images/regular_expressions.png")
```

## Regular Expressions

</br>
</br>
</br>

> "Regexps are a very terse language that allow you to describe patterns in strings."
>
> *R for Data Science*

## 

R uses "extended" regular expressions, which are common.

```{r}
#| echo: true
#| eval: false

str_detect(string  = my_string_vector, 
           pattern = "REGULAR EXPRESSION"
           )
```

::: callout-tip
Regular expressions are a reason to use `stringr`!

You might encounter `gsub()`, `grep()`, etc. from Base R.
:::

## Meta Characters `.` `^` `$` `\` `|` `*` `+` `?` `{` `}` `[` `]` `(` `)`

::: panel-tabset
### Wild card `.`

```{r}
#| echo: true
#| code-line-numbers: false
toung_twister <- c("She", "sells", "seashells", "by", "the", "seashore!")
```

`.` Represents any character

```{r}
#| echo: true
str_subset(toung_twister, pattern = ".ells")
```

### Anchoring `^ $`

```{r}
#| echo: true
#| code-line-numbers: false
toung_twister <- c("She", "sells", "seashells", "by", "the", "seashore!")
```

</br>

::: columns
::: {.column width="45%"}
`^` Looks at the beginning

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(toung_twister, 
           pattern = "^s")
```
:::

::: {.column width="5%"}
:::

::: {.column width="45%"}
`$` Looks at the end

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(toung_twister, 
           pattern = "s$")
```

:::
:::


### Quantifiers `? + *`

```{r}
#| echo: true
#| code-line-numbers: false
shells_str <- c("shes", "shels", "shells", "shellls", "shelllls")
```

::: columns
::: {.column width="33%"}
`?` Occurs 0 or 1 times

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(shells_str, 
           pattern = "shel?s")
```

:::

::: {.column width="33%"}
`+` Occurs 1 or more times

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(shells_str, 
           pattern = "shel+s")
```
:::

::: {.column width="33%"}
`*` Occurs 0 or more times

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(shells_str, 
           pattern = "shel*s")
```
:::
:::


### More Quantifiers `{}`

```{r}
#| echo: true
#| code-line-numbers: false
shells_str <- c("shes", "shels", "shells", "shellls", "shelllls")
```

::: columns
::: {.column width="33%"}
`{n}` matches exactly n times.

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(shells_str, 
           pattern = "shel{2}s")
```

:::

::: {.column width="33%"}
`{n,}` matches at least n times.

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(shells_str, 
           pattern = "shel{2,}s")
```
:::

::: {.column width="33%"}
`{n,m}` matches between n and m times.

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(shells_str, 
           pattern = "shel{1,3}s")
```
:::
:::

:::

## Groups `()`

+ Similar to our `filter()` statements, `|` means "or"

```{r}
#| echo: true
#| code-line-numbers: false
toung_twister2 <- c("Peter", "Piper", "picked", "a",
                    "peck", "of", "pickled", "peppers!")

```

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(toung_twister2, 
           pattern = "p(e|i)ck")
```

::: {.callout-tip}
A lot of the benefit of groups is the ability to back reference positions of a string.
:::

## Character Classes 

>  are defined by `[]` and let you match a set of characters

```{r}
#| echo: true
#| code-line-numbers: false
toung_twister2 <- c("Peter", "Piper", "picked", "a", 
                    "peck", "of", "pickled", "peppers!")
```

. . .

</br>

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(toung_twister2, 
           pattern = "p[ei]ck")
```

::: {.callout-note}
Notice how you could have accomplished the same thing with `pattern = "p(e|i)ck"`?
:::

## More Character Classes!

`[^ ]` except - think "not"

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(toung_twister2, pattern = "p[^i]ck")
```

. . .

`[ - ]` range

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(toung_twister2, pattern = "p[ei]ck[a-z]")
```

. . .

`[Pp]` Capitalization matters

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(toung_twister2, pattern = "^p")
```

```{r}
#| echo: true
#| code-line-numbers: false
str_subset(toung_twister2, pattern = "^[Pp]")
```

## Even More Character Classes

::: panel-tabset
### Shortcuts

-   \[A-Z\] matches any capital letter.
-   \[a-z\] matches any lowercase letter.
-   \[A-z\] or \[:alpha:\] matches any letter
-   \[0-9\] or \[:digit:\] matches any number
-   See the stringr cheatsheet for more shortcuts, like \[:punct:\]

### More Shortcuts

`\w` Looks for any **"word"** (conversely "not" "word" `\W`)

`\d` Looks for any **digit** (conversely "not" digit `\D`)

`\s` Looks for any **whitespace** (conversely "not" whitespace `\S`)
:::

## Let's try it out!

Discuss with a neighbor which regular expressions would search for words that do the following:

-   end with a vowel
-   start with x, y, or z
-   *do not* contain x, y, or z

## Escape `\`

In order to match a special character you need to "escape" first

::: callout-warning
In general, look at punctuation characters with suspicion.
:::

```{r}
#| echo: true
#| code-line-numbers: false
toung_twister3 <- c("How", "much", "wood", "could", 
                    "a", "woodchuck", "chuck", "if", "a", 
                    "woodchuck", "could", "chuck", "wood?")
```

```{r}
#| echo: true
#| error: true
str_subset(toung_twister3, pattern = "?")
```

</br>

```{r}
#| echo: true
#| error: true
str_subset(toung_twister3, pattern = "\\?")
```

## When in Doubt

<br> <br>

```{r}
#| fig-align: center
#| out-width: 80%
knitr::include_graphics("images/backslashes.png")
```

Use this [web app to test R regular expressions](https://spannbaueradam.shinyapps.io/r_regex_tester/)

## Tips for working with regex

-   Read the regular expressions out loud like a "request"

. . .

-   Test out your expressions on small examples first
    -   [Web app to test R regular expressions](https://spannbaueradam.shinyapps.io/r_regex_tester/)
    -   `str_view()` and `str_view_all()`

::: {.callout-note collapse="true"}
### `str_view()` and `str_view_all()`

```{r}
#| echo: true
shells_str
str_view(shells_str, "l+")
str_view_all(shells_str, "l+")
```
:::

## Tips for working with regex

-   Read the regular expressions out loud like a "request"

-   Test out your expressions on small examples first

    -   [Web app to test R regular expressions](https://spannbaueradam.shinyapps.io/r_regex_tester/)
    -   `str_view()` and `str_view_all()`

-   I use the [`stringr` cheatsheet](https://posit.co/wp-content/uploads/2022/10/strings-1.pdf) more than any other package cheatsheet!

. . .

-   Everyone has a love-hate relationship with regular expressions. Be kind to yourself.

# strings in the `tidyverse`

```{r}
#| include: false
library(readxl)
library(tidyverse)
military <- read_xlsx(here::here("4_tidyr-joins",
                                 "Practice Activity",
                                 "data", 
                                 "gov_spending_per_capita.xlsx"), 
                      sheet = "Share of Govt. spending", 
                      skip  = 7, 
                      n_max  = 191)
```

## `matches(pattern)`

Selects all variables with a name that matches the supplied pattern

-   pairs well with `select()`, `rename_with()`, and `across()`

::: panel-tabset
### Before

```{r}
#| echo: true
military_clean <- military |> 
  mutate(across(`1988`:`2019`, 
                ~ na_if(.x, y = ". .")
                ),
         across(`1988`:`2019`, 
                ~ na_if(.x, y = "xxx")
                )
         )
```

### With regex

```{r}
#| echo: true

military_clean <- military |> 
  mutate(
         across(matches("[1-9]{4}"), 
                ~ na_if(.x, y = ". .")
                ),
         across(matches("[1-9]{4}"), 
                ~ na_if(.x, y = "xxx")
                )
         )
```
:::

## "Messy" Covid Variants

A friend of mine received a dataset the other day from someone who asked if she knew how to "clean" it.

![](images/covid-data-snip.png)

What is that column?! `r emo::ji("wow")`

`[{'variant': 'Other', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 4.59}, {'variant': 'V-20DEC-01 (Alpha)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-21APR-02 (Delta B.1.617.2)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-21OCT-01 (Delta AY 4.2)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-22DEC-01 (Omicron CH.1.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 24.56}, {'variant': 'V-22JUL-01 (Omicron BA.2.75)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 8.93}, {'variant': 'V-22OCT-01 (Omicron BQ.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 49.57}, {'variant': 'VOC-21NOV-01 (Omicron BA.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 0.02}, {'variant': 'VOC-22APR-03 (Omicron BA.4)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 0.08}, {'variant': 'VOC-22APR-04 (Omicron BA.5)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 5.59}, {'variant': 'VOC-22JAN-01 (Omicron BA.2)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 1.41}, {'variant': 'unclassified_variant', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 5.26}]`

## Enter `stringr`! `r emo::ji("party")`

Let's see how this works.

## PA 5.2: Scrambled Message

In this activity, you will be using regular expressions to decode a message.

For the activity, you are able to choose what type of object you want to work with -- a **vector** or a **dataframe**. 

## Dataframes

If you choose to work with dataframes, remember the `stringr` functions go *inside* `dplyr` verbs like `mutate()` and `filter()`. Think of them as you would `as.factor()`. 

</br>

```{r}
#| echo: true
#| code-line-numbers: false

cereal |> 
  mutate(
    is_bran = str_detect(name, "Bran")
  )
```



## Vectors

If you choose to work with vectors, it is important you remember how to index a vector's contents! 

. . .

-   You can grab the elements out of a vector with \[\] -- read "where"

```{r}
#| echo: true
#| code-line-numbers: false
toung_twister3[c(3, 6, 10, 13)]
```


-   If you want to replace those elements or change those elements use the assignment arrow!

```{r}
#| echo: true
#| code-line-numbers: false
toung_twister3[c(3, 6, 10, 13)] <- "WOOD!"
```
