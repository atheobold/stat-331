---
title: "STAT 331"
title-slide-attributes:
    data-background-image: images/stringr_horst.png
    data-background-size: contain
    data-background-opacity: "0.5"
format: 
  revealjs:
    self-contained: true
    auto-stretch: false
editor: visual
execute: 
  echo: false
---

```{r setup}
#| include: false
#| message: false
library(tidyverse)
library(palmerpenguins)

# cereal data
library(liver)
data(cereal)
```

## strings

A **string** is a bunch of **characters**.

Don't confuse a **string** (many characters, one object) with a **character vector** (vector of strings).

<br>

```{r}
#| echo: true
my_string <- "Hi, my name is Bond!"
my_vector <- c("Hi", "my", "name", "is", "Bond")
```

<br>

```{r}
#| echo: true
my_string
```

<br>

```{r}
#| echo: true
my_vector
```

# `stringr`

:::: columns
::: column
**Common tasks**

+ Find which strings contain a particular pattern

+ Remove or replace a pattern

+ Edit a string (for example, make it lowercase)
:::
::: column
```{r}
#| fig-align: center
#| out-width: 40%
knitr::include_graphics("https://github.com/rstudio/hex-stickers/blob/main/PNG/stringr.png?raw=true")
```
:::
::::

::: callout-note 
The package `stringr` is very useful for strings!  

+ `stringr` **does** load with the `tidyverse`.

+ all the functions are `str_xxx()`.
:::

## `pattern = `

The **pattern argument** in all of the `stringr` functions ...

```{r}
#| eval: false
#| echo: true
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")

str_detect(my_vector, pattern = "Bond")
str_locate(my_vector, pattern = "Bond")
str_match(my_vector, pattern = "Bond")
str_extract(my_vector, pattern = "Bond")
str_subset(my_vector, "pattern = Bond")
```

::: callout-note
Discuss with a neighbor. For each of these functions, give:

+ The **object structure** of the output.
+ The **data type** of the output.
+ A brief explanation of what they do.
::::


## `str_detect()`

Returns **logical vector** `TRUE/FALSE` indicating if the pattern was found in that element of the original vector

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_detect(my_vector, pattern = "Bond")
```

</br>

. . .

+ Pairs well with `filter()`
+ Could be used with `summarise()` and `sum()` or `mean()`

::: {.callout-note collapse="true"}
### Related functions 
`str_subset()` returns just the strings that contain the match

`str_which()` returns the indexes of strings that have a match
:::

## `str_match()` 

Returns **character matrix** with either `NA` or the pattern, depending on if the pattern was found.

</br>

```{r}
#| echo: true
#| code-line-numbers: false

my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_match(my_vector, pattern = "Bond")
```

## `str_extract()` 

Returns **character vector** with either `NA` or the *pattern*, depending on if the pattern was found.

</br>

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_extract(my_vector, pattern = "Bond")
```

. . .

</br>

::: callout-warning
`str_extract()` only returns the **first** pattern match.

Use `str_extract_all()` to return **every** pattern match.
:::

## `str_locate()` 

Returns a **date frame** with two **numeric variables** for the starting and ending location, giving either `NA` or the start and end position of the pattern.

</br>

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_locate(my_vector, pattern = "Bond")
```

## `str_subset()`

Returns a **character vector** with a subset of the original **character vector** with elements where the pattern occurs.

</br>

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_subset(my_vector, pattern = "Bond")
```

</br>

::: callout-note
### Related Functions

`str_sub()` extracts values based on location (starting and ending position).
:::

## Replace / Remove patterns

::: panel-tabset

### `str_replace()`

::: {style="font-size: 0.75em"}
Replaces the [first]{.underline} matched pattern

+ Pairs well with `mutate()`
:::

</br>

```{r}
#| echo: true
#| code-line-numbers: false
str_replace(my_vector, pattern = "Bond", replace = "Franco")
```

### `str_remove()`

::: {style="font-size: 0.75em"}
Removes the [first]{.underline} matched pattern

+ You could think of `str_remove()` as a special case of `str_replace( )`, where the `replace` argument is empty (`""`).
:::

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_remove(my_vector, pattern = "Bond")
```

:::

::: {.callout-note collapse="true"}
### Related functions 

`str_replace_all()` replaces **all** matched patterns

`str_remove_all()` removes **all** matched patterns
:::

## Make edits

::: {style="font-size: 0.75em"}
Convert letters in the string to a specific capitalization format.
:::

::: panel-tabset

### `str_to_lower()` 

::: {style="font-size: 0.75em"}
converts all letters in the strings to lowercase
:::

<br>

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_to_lower(my_vector)
```

### `str_to_upper()` 

::: {style="font-size: 0.75em"}
converts all letters in the strings to uppercase
:::

```{r}
#| echo: true
#| code-line-numbers: false

str_to_upper(my_vector)
```

### `str_to_title()` 

::: {style="font-size: 0.75em"}
converts the first letter of the strings to uppercase
:::


```{r}
#| echo: true
#| code-line-numbers: false
str_to_title(my_vector)
```

:::

## Combine Strings

::: panel-tabset
### `str_c()`

::: {style="font-size: 0.75em"}
Joins multiple strings into a single string

+ `sep` argument declares how the strings should be separated when pasting
:::

```{r}
#| echo: true
#| code-line-numbers: false
prompt <- "Hello, my name is"
first  <- "James"
last   <- "Bond"
str_c(prompt, last, ",", first, last, sep = " ")
```

::: callout-note
Similar to `paste()` and `paste0()`
:::

### `str_flatten()`

::: {style="font-size: 0.75em"}
Combines into a single string.
:::

```{r}
#| echo: true
#| code-line-numbers: false
my_vector <- c("Hello,", "my name is", "Bond", "James Bond")
str_flatten(my_vector, collapse = " ")
```

::: callout-note
`str_c()` will do the same thing, but it it is encouraged to use `str_flatten()` instead.
:::

### `str_glue()`

::: {style="font-size: 0.75em"}
Uses environment to create a string and evaluates {expressions}.
:::

```{r}
#| echo: true
#| code-line-numbers: false
first <- "James"
last <- "Bond"
str_glue("My name is {last}, {first} {last}")
```

::: callout-tip
See the R package [`glue`](https://glue.tidyverse.org/)! We will use these tools *a lot* in Week 7!
:::

:::

## Tips for Success

+ Refer to the [`stringr` cheatsheet](https://posit.co/wp-content/uploads/2022/10/strings-1.pdf)

+ Remember that `str_xxx` functions need the first argument to be a **vector of strings**, not a **data set**.
  + You might want to use them *inside* functions like `filter()` or `mutate()`.

```{r}
#| echo: true
cereal |> 
  mutate(
    is_bran = str_detect(name, "Bran"), 
    .after = name
  )
```

# regex

```{r}
#| fig-align: center
#| out-width: 70%
knitr::include_graphics("images/regular_expressions.png")
```

## Regular Expressions

> "Regexps are a very terse language that allow you to describe patterns in 
> strings."
>
> *R for Data Science*

</br>

R uses "extended" regular expressions, which are common.

```{r}
#| echo: true
#| eval: false

str_detect(string  = my_string_vector, 
           pattern = "REGULAR EXPRESSION"
           )
```

</br>

::: callout-tip
Regular expressions are a reason to use `stringr`!

You might encounter `gsub()`, `grep()`, etc. from Base R.
:::

## Meta Characters `.` `^`  `$` `\`  `|` `*` `+` `?` `{` `}` `[` `]` `(` `)`

::: panel-tabset

### Wild card `.`

```{r}
#| echo: true
toung_twister <- c("She", "sells", "seashells", "by", "the", "seashore!")
toung_twister
```
<br>
`.` Represents any character

```{r}
#| echo: true
str_subset(toung_twister, pattern = ".ells")
```

### Anchoring `^ $`

```{r}
#| echo: true
toung_twister <- c("She", "sells", "seashells", "by", "the", "seashore!")
toung_twister
```

<br>

`^` Looks at the beginning  

```{r}
#| echo: true
str_subset(toung_twister, pattern = "^s")
```

`$` Looks at the end  

```{r}
#| echo: true
str_subset(toung_twister, pattern = "s$")
```

### Quantifiers `? + *`

```{r}
#| echo: true
shells_str <- c("shes", "shels", "shells", "shellls", "shelllls")
shells_str
```

<br>

`?` Occurs 0 or 1 times  

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel?s")
```

`+` Occurs 1 or more times

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel+s")
```

`*` Occurs 0 or more times

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel*s")
```

### More Quantifiers `{}`

```{r}
#| echo: true
shells_str <- c("shes", "shels", "shells", "shellls", "shelllls")
shells_str
```

<br>

`{n}` matches exactly n times.

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel{2}s")
```

`{n,}` matches at least n times.

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel{2,}s")
```

`{n,m}` matches between n and m times.

```{r}
#| echo: true
str_subset(shells_str, pattern = "shel{1,3}s")
```
:::

## Groups `()`

Groups can be created with `( )`

`|` -- "either" / "or"

<br>
```{r}
#| echo: true
toung_twister2 <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers!")
toung_twister2
```

<br>

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "p(e|i)ck")
```

## Character Classes `[]`

```{r}
#| echo: true
toung_twister2 <- c("Peter", "Piper", "picked", "a", "peck", "of", "pickled", "peppers!")
```

. . .

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "p[ei]ck")
```
. . .

`[^ ]` except - think "not"

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "p[^i]ck")
```

. . .

`[ - ]` range

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "p[ei]ck[a-z]")
```

. . .

`[Pp]` Capitalization matters

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "^p")
```

```{r}
#| echo: true
str_subset(toung_twister2, pattern = "^[Pp]")
```

## `[]` Character Classes

::: panel-tabset
### Shortcuts
+ [A-Z] matches any capital letter.
+ [a-z] matches any lowercase letter.
+ [A-z] or [:alpha:] matches any letter
+ [0-9] or [:digit:] matches any number
+ See the stringr cheatsheet for more shortcuts, like [:punct:]

### More Shortcuts
`\w` Looks for any **"word"**  (conversely "not" "word" `\W`) 

`\d` Looks for any **digit** (conversely "not" digit `\D`) 

`\s` Looks for any **whitespace** (conversely "not" whitespace `\S`) 
:::

## Let's try it out!

Discuss with a neighbor which regular expressions would search for words that do the following:

+ end with a vowel
+ start with x, y, or z
+ *do not* contain x, y, or z
+ contain [British spelling](https://www.oxfordinternationalenglish.com/differences-in-british-and-american-spelling/)

Test your answers out on

```{r}
#| echo: true
test_vec <- c("zebra", "xray", "apple", "yellow", "color", "colour", "summarize", "summarise")
```

## Escape `\`

In order to match a special character you need to "escape" first

::: callout-warning
In general, look at punctuation characters with suspicion.
:::

```{r}
toung_twister3 <- c("How", "much", "wood", "could", "a", "woodchuck", "chuck", "if", "a", "woodchuck", "could", "chuck", "wood?")
toung_twister3 
```
```{r}
#| echo: true
#| error: true
str_subset(toung_twister3, pattern = "?")
```

```{r}
#| echo: true
#| error: true
str_subset(toung_twister3, pattern = "\\?")
```

::: callout-note
Could also use `[]` character class

```{r}
#| echo: true
#| error: true
str_subset(toung_twister3, pattern = "[?]")
```
:::

## When in Doubt
<br>
<br>
```{r}
#| fig-align: center
#| out-width: 80%
knitr::include_graphics("images/backslashes.png")
```
Use the [web app to test R regular expressions](https://spannbaueradam.shinyapps.io/r_regex_tester/)

## Tips for working with regex

+ Read the regular expressions out loud like a "request"

. . .

+ Test out your expressions on small examples first
  + [Web app to test R regular expressions](https://spannbaueradam.shinyapps.io/r_regex_tester/)
  + `str_view()` and `str_view_all()`

::: {.callout-note collapse="true"}  
### `str_view()` and `str_view_all()`
```{r}
#| echo: true
shells_str
str_view(shells_str, "l+")
str_view_all(shells_str, "l+")
```
:::

## Tips for working with regex

+ Read the regular expressions out loud like a "request"

+ Test out your expressions on small examples first
  + [Web app to test R regular expressions](https://spannbaueradam.shinyapps.io/r_regex_tester/)
  + `str_view()` and `str_view_all()`

+ I use the [`stringr` cheatsheet](https://posit.co/wp-content/uploads/2022/10/strings-1.pdf) more than any other package cheatsheet!

. . .

+ Everyone has a love-hate relationship with regular expressions. Be kind to yourself.

# strings in the `tidyverse`

```{r}
#| include: false
library(readxl)
library(tidyverse)
military <- read_xlsx(here::here("4_tidyr-joins",
                                 "Practice Activity",
                                 "data", 
                                 "gov_spending_per_capita.xlsx"), 
                      sheet = "Share of Govt. spending", 
                      skip  = 7, 
                      n_max  = 191)
```

## `matches(pattern)`

Selects all variables with a name that matches the supplied pattern

+ pairs well with `select()`, `rename_with()`, and `across()`

::: panel-tabset

### Before
```{r}
#| echo: true
military_clean <- military |> 
  mutate(across(`1988`:`2019`, 
                ~ na_if(.x, y = ". .")
                ),
         across(`1988`:`2019`, 
                ~ na_if(.x, y = "xxx")
                )
         )
```

### With regex
```{r}
#| echo: true

military_clean <- military |> 
  mutate(
         across(matches("[1-9][1-9][1-9][1-9]"), 
                ~ na_if(.x, y = ". .")
                ),
         across(matches("[1-9][1-9][1-9][1-9]"), 
                ~ na_if(.x, y = "xxx")
                )
         )
```
:::

## "Messy" Covid Variants

I received this data from a grad school colleague the other day who asked if I knew how to "clean" it.

![](images/covid-data-snip.JPG)

What is that column?! `r emo::ji("wow")`

`[{'variant': 'Other', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 4.59}, {'variant': 'V-20DEC-01 (Alpha)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-21APR-02 (Delta B.1.617.2)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-21OCT-01 (Delta AY 4.2)', 'cumWeeklySequenced': 0.0, 'newWeeklyPercentage': 0.0}, {'variant': 'V-22DEC-01 (Omicron CH.1.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 24.56}, {'variant': 'V-22JUL-01 (Omicron BA.2.75)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 8.93}, {'variant': 'V-22OCT-01 (Omicron BQ.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 49.57}, {'variant': 'VOC-21NOV-01 (Omicron BA.1)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 0.02}, {'variant': 'VOC-22APR-03 (Omicron BA.4)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 0.08}, {'variant': 'VOC-22APR-04 (Omicron BA.5)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 5.59}, {'variant': 'VOC-22JAN-01 (Omicron BA.2)', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 1.41}, {'variant': 'unclassified_variant', 'cumWeeklySequenced': 2366843.0, 'newWeeklyPercentage': 5.26}]`

## Enter `stringr`! `r emo::ji("party")`

Let's see how this works.

## [PA 5.2: Scrambled Message](https://earobinson95.github.io/stat331-calpoly/practice-activities/PA5_2-scrambled-message-regex.html)

In this activity, you will be using regular expressions to decode a message.

+ Remember, the `stringr` functions go *inside* `dplyr` verbs like `mutate()` and `filter()`. Think of them as you would `as.factor()`

+ [Reminder about Indexing Vectors](https://earobinson95.github.io/stat331-calpoly-text/00-prereading.html#indexing-by-location)

```{r}
#| echo: true
toung_twister3
```

  + You can grab the elements out of a vector with [] -- read "where"

```{r}
#| echo: true
toung_twister3[c(3,6, 10,13)]
```

  + If you want to replace those elements or change those elements use the assignment arrow!

```{r}
#| echo: true
toung_twister3[c(3,6, 10,13)] <- "WOOD!"
```

## To do...

+ **PA 5.2: Scrambled Message**
  + Due Friday, 2/10 at 8:00am

+ **Lab 5: Factors in Data Visualization**
  + Due Friday, 2/10 at 11:59pm

+ **Final Project Group Formation Survey**
  + Due Friday, 2/10 at 11:59pm

+ [**Bonus Challenge: Murder Mystery in SQL City**](https://earobinson95.github.io/stat331-calpoly/bonus-challenges/bonus-challenge-murder-in-sql-city.html)
  + Due Sunday 2/12 at 11:59pm
  
+ **Read Chapter 6: Version Control**
  + **Concept Check 6.1 + 6.2** due Monday (2/13) at 8:00am

  