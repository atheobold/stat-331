---
title: "Coding for Exercises"
author: "Allison Theobold"
date: "4/25/2021"
output: html_document
---

```{r setup, include=FALSE}
library(stringr)
library(tidyverse)
```

## Section 1 -- Combining Strings & Substrings

1. `paste()` and `paste0()` are two versions of `str_c()`. `paste()` takes 
arguments of how the objects should be `sep`arated, how they should be 
`collapse`d, and if they should be `recycle`d. `paste0()` is a special 
counterpart to `paste()` where `sep` is automatically set to no space. These 
functions will paste the NA values, essentially treating them as characters. 
These functions will automatically recycle entries of a vector if the lengths 
differ. 

Alternatively, `str_c()` allows for you to paste things together with **any** 
separation (much more general). This function **will not** paste NA values, 
only pasting the corresponding entries where there are not missing values. 
This function *will* recycle entries from vectors of different lengths, **but** 
the function will output a warning to let you know this happened! 

2. The `sep` argument is what character(s) should be used to separate the
entries. The `collapse` argument is what character(s) should be used to 
make a **single** string of the entries. 

3. 

```{r}
x <- c("abc", "defg", "hij", "klmno")

str_length(x)
start_stop <- ceiling(str_length(x)/2)
str_sub(x, start_stop, start_stop)
```

4. The `str_wrap()` function wraps long strings based on a `width` specification
(number of characters wide). You can also use this to indent! 

5. The `str_trim()` function removes whitespace from the beginning and end of 
a string. You can specify what side to remove the whitespace from (left, right, 
or both). The opposite is `str_pad()` which adds whitespace to a string. You 
can pad a specified side of both, and select what character to pad with (default
is whitespace). 

6. 

```{r}
letters <- c("a", "b", "c", "d", "e")

make_string <- function(x){
  len <- length(x)
  
  ## n = 0, empty vector
  if(len == 0) {
    ""
  } else if(len == 1) {
    x
    } else if(len == 2) {
    str_c(x[1], " and ", x[2])
  } else{
    not_end <- str_c(x[seq_len(len - 1)], collapse = ", ")
    end <- str_c("and ", x[len])
    str_c(c(not_end, end), collapse = " ")
  }
}

make_string(letters)

```


## Section 2 -- Matching Patterns with Regex

Useful functions:
```{r}
str_view(letters, "^a")

slashes <- "\\\\"
writeLines(slashes)
```

1. Matching a "\" needs "\\" regular expression 
"\" only escapes
"\\" escapes the first "\" and prints as a "\" which escapes the next character
"\\\" escapes the first \, but then the next "\" is a special character and 
will throw an error (really make R wait for another character it can escape). 

2. "'\

\" then ' then \\ 
To Match: need \\\\ instead of \\!

```{r}
writeLines("\"'\\")

str_view("\"'\\", "\"'\\\\", match = TRUE)
```

3. \. escapes the dot, the following . represents any letter
strings like: .a.b.c


## Section 3

