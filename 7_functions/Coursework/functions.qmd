---
title: "Writing User-Defined Functions in R"
format: 
  html: 
    self-contained: true
    theme: minty
    fontsize: 1em
    mainfont: sans-serif
    number-sections: true
    number-depth: 2
    code-block-bg: "#76b5c5"
    highlight-style: monochrome
editor: visual
execute: 
  echo: true
---

```{r}
#| include: false
#| echo: false

library(tidyverse)
library(lubridate)
```

This week you will learn to:

-   Write your own functions in R

-   Make good decisions about function arguments and returns

-   Include side effects and / or error messages in your functions

-   Extend your use of good R coding style

------------------------------------------------------------------------

`r emo::ji("play button")` Watch Videos: 22 minutes

-   `r emo::ji("link")` Link to **all** Slides from Videos: [here](https://app.box.com/s/bctcjsbysmpv0vs84izzeqk09sx7mz00)

`r emo::ji("book")` Readings: 60-75 minutes

`r emo::ji("computer")` Activities: 60-75 minutes

`r emo::ji("check")` Preview Activities: 1

---

# Why Write a Function?

You might be coming into this chapter wondering, "Why would I write a function?". Especially, if thus far you've been able to do everything with built-in functions and / or reusing your code a few times.

The critical motivation behind functions is the "don't repeat yourself" (DRY) principle. In general, "you should consider writing a function whenever copied and pasted your code **more than twice** (i.e. you now have three copies of the same code)" (Wickham & Grolemund, 2020).

One of my favorite papers, *Best Practices for Scientific Computing*, summarizes this idea in a slightly different way:

> Anything that is repeated in two or more places is more difficult to maintain. Every time a change or correction is made, multiple locations must be updated, which increases the chance of errors and inconsistencies. To avoid this, programmers follow the DRY Principle, which applies to both data and code.

The DRY Principle applies at two scales: small and large. At small scales, researchers (**you**) should work to modularize code instead of copying and pasting. Modularizing your code helps you remember what the code is doing as a single mental chunk. This makes your code easier to understand, since there is less to remember! Another perk is that your modularized code can also be more easily re-purposed for other projects. At larger scales, it is vital that scientific programmers (**you**) re-use code instead of rewriting it (Wilson et al., 2014).

If you are interested in reading more about these "best practices" you can find the article here: <https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.1001745>

# Writing Functions

`r emo::ji("book")` [Recommended Reading: *R4DS* -- Functions](https://r4ds.hadley.nz/functions.html)

`r emo::ji("play button")` [Recommended Video: Why write a function? -- 5 minutes](http://somup.com/crh6eXFmMK)

`r emo::ji("play button")` [Recommended Video: Components of a function -- 10 minutes](http://somup.com/crh6euFmNj)

`r emo::ji("play button")` [Recommended Video: Function environments -- 6 minutes](http://somup.com/crh6eBFmNK)

`r emo::ji("computer")` [Required Tutorial: RStudio Primer -- Writing Functions](https://rstudio.cloud/learn/primers/6)

::: callout-tip
I **highly recommend** you work through *every* tutorial except Loops!
:::

## `r emo::ji("check")` **Preview Activity 7**

### Part 1 -- Writing Simple Functions

Fill in the necessary code to write a function called `times_seven()`. The function should take a single argument (`x`) and multiply the input by 7.

- This function should check that the argument is numeric.
- This function should also excitedly announce (print) "I love sevens!" if the argument to the function is a 7.

```{r, eval = FALSE}
times_seven <- function(x){
  stopifnot(___)
  
  if(___){
    print(___)
  }
  return(___)
}

```

### Part 2 -- Predicting Function Behavior

```{r addtwo}
add_or_subtract <- function(first_num, 
                            second_num = 2, 
                            type = "add") {
  
  if (type == "add") {
    first_num + second_num
  } else if (type == "subtract") {
    first_num - second_num
  } else {
    stop("Please choose `add` or `subtract` as the type.")
  }
  
}
  
```

For the four calls to the `add_or_subtract()` function, which of the following will be output?

i)  1
ii) -1
iii) 30
iv) An error defined by the function `add_or_subtract()`
v)  An error defined in a different function, which is called inside the `add_or_subtract()` function

```{r, eval = FALSE}
add_or_subtract(5, 6, type = "subtract")

add_or_subtract("orange")

add_or_subtract(5, 6, type = "multiply")

```

### Part 3 -- Global Environments

Consider the following code:

```{r}
first_num <- 5
second_num <- 3

result <- 8

result <- add_or_subtract(first_num, second_num = 4)

result_2 <- add_or_subtract(first_num)
```

In your Global Environment, what is the value of...

a)  `first_num`
b)  `second_num`
c)  `result`
d)  `result_2`

## Styling Functions

Part of writing reproducible and shareable code is following good **style guidelines**. Mostly, this means choosing good object names and using white space in a consistent and clear way.

You should have already read the sections of the Tidyverse Style Guide relevant to piping, plotting, and naming objects. This week we are extending these style guides to functions.

I would **highly recommend** reading through the style guide for naming functions, what to do with long lines, and the use of comments. The guide can be found here: <https://style.tidyverse.org/functions.html>

### Summary

Designing functions is somewhat subjective, but there are a few principles that apply:

1.  Choose a good, descriptive **names**
    -   Your function name should describe what it does, and usually involves a verb.
    -   Your argument names should be simple and / or descriptive.
    -   Names of variables in the body of the function should be descriptive.
2.  Output should be **very predictable**
    -   Your function should always *return* the same object type, no matter what input it gets.
    -   Your function should expect certain objects or object types as *input*, and give errors when it does not get them.
    -   Your function should give errors or warnings for common mistakes.
    -   Default values of arguments should only be used when there is a clear common choice.
3.  The body of the function should be **easy to read**.
    -   Code should use [good style principles](https://style.tidyverse.org/).
    -   There should be occasional comments to explain the purpose of the steps.
    -   Complicated steps, or steps that are repeated many times, should be written into **separate functions** (sometimes called *helper functions*).
4.  Functions should be **self-contained**.
    -   They should not rely on any information besides what is given as input.
    -   *(Relying on other functions* is fine, though)
    -   They should not alter the Global Environment
    -   *Functions should **never** load or install packages!*
