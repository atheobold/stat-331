---
title: "More About Function Arguments"
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: ["xaringan-themer.css", "slide-style.css"]
    nature:
      highlightStyle: solarized-light
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
      slideNumberFormat: |
        <div class="progress-bar-container">
          <div class="progress-bar" style="width: calc(%current% / %total% * 100%);">
          </div>
        </div>
---


```{r, echo = FALSE, message = FALSE, warning = FALSE, fig.width = 8, fig.height = 6}
knitr::opts_chunk$set(message = FALSE, 
                      warning = FALSE, 
                      fig.align = "center")

options(htmltools.dir.version = FALSE)

library(xaringanthemer)
library(xaringan)
library(tidyverse)
library(flair)
library(palmerpenguins)

style_duo_accent(
  primary_color      = "#0F4C81", # pantone classic blue
  secondary_color    = "#B6CADA", # pantone baby blue
  header_font_google = google_font("Raleway"),
  text_font_google   = google_font("Raleway", "300", "300i"),
  code_font_google   = google_font("Source Code Pro"),
  text_font_size     = "30px"
)
```


.larger[Standardizing]


```{r}
standardize <- function(data) {
  deviations <- data - mean(data, na.rm = TRUE)
  newdata <- deviations / sd(data, na.rm = TRUE)
  return(newdata)
}
```

---

.larger[Still...] 

We haven't eliminated copy-and-pasting from our `penguins` dataset! 

```{r, eval = FALSE}
penguins$bill_length_mm <- standardize(penguins$bill_length_mm)
penguins$bill_depth_mm <- standardize(penguins$bill_depth_mm)
penguins$flipper_length_mm <- standardize(penguins$flipper_length_mm)
penguins$body_mass_g <- standardize(penguins$body_mass_g)
```

--

<center>

**What should we do?** 


---

class: inverse

.huge-text[Familiar Option]

---

.larger[`across()`]

```{r}
penguins %>% 
  mutate(across(.cols = bill_length_mm:body_mass_g,
                .fns = standardize)
  )
```

---

class: inverse

.huge-text[New Option]

---

.larger[Variables as Arguments]


```{r stdcol}
stdize_column <- function(dat, variable) {
  dat <- dat %>%
    mutate(
      variable = standardize(variable)
    )
  return(dat)
}
```

*(Notice how we relied on the existing function `standarize()` inside the new
function, for clarity!)*

---

.larger[Variables as arguments]

Alas...

```{r, error = TRUE}
stdize_column(penguins, body_mass_g)
```

--

<center>

**What happened?**

---

# Tidy evaluation

Functions that use **unquoted** variable names as arguments are called
**nonstandard evaluation** or **tidy evaluation**.

--


.pull-left[
**Tidy**:

```{r, eval = FALSE}
penguins %>% pull(body_mass_g)
```


```{r, eval = FALSE}
penguins$body_mass_g
```
]

--

.pull-right[
**Untidy**: 

```{r, eval = FALSE}
penguins["body_mass_g"]
```


```{r, eval = FALSE}
penguins[["body_mass_g"]]
```
]

--

</br>

<center> 

**But they are complicated to write!**

---

class: middle, center, inverse

.huge-text[What to do?]

---

.larger[Option 1 `r emo::ji("shrug")`] 

--

</br>

.bitlarger[**Just don't use it in your functions.**]

</br>

.bitlarger[**Harder to read/use, but safe.**]

---

```{r}
stdize_column <- function(data, variable) {
  data[[variable]] <- standardize(data[[variable]])
  return(data)
}

stdize_column(penguins, "body_mass_g")
```

---

.larger[Option 2 -- Tunnel] 

In February 2020 **rlang** introduced the curly-curly `{{ }}` operator to
simplify writing functions around tidyverse pipelines. 

--

With the "embracing operator" (`{{`) you can tunnel data-variables (i.e. columns
from the data frames) through function arguments! 

<!-- The curly-curly operator {{ }} for function arguments is a bit special because it forces the function argument and immediately defuses it. The defused expression is substituted in place, ready to be evaluated in another context, such as the data frame. -->

--

**This only works for `select()` type functions, that use the literal name of
the variable to subset the data.**


[Article on How Building Functions with Variable Names has Changed Over the Years](https://www.bryanshalloway.com/2020/06/25/using-across-to-build-functions-with-dplyr-with-notes-on-legacy-approaches/)

---

.larger[Recall]

.pull-left[

```{r stdcol}
stdize_column <- function(dat, variable) {
  dat <- dat %>%
    mutate(
      variable = standardize(variable)
    )
  return(dat)
}

stdize_column(penguins, body_mass_g)
```
]

.pull-right[
The problem here is that `mutate()` defuses the R code it was supplied. 

Instead we want it to see `body_mass_g = standardize(body_mass_g)`. 

This is why we need injection!

We need to modify that piece of code by injecting the code supplied to the
function in place of `variable`.
]

---

,larger[What is data masking?}

.pull-left[

![](images/rlang.png)
]

.pull-right[

]

--


[Link to **rlang** article](https://rlang.r-lib.org/reference/topic-data-mask.html)

---

```{r tunnel, eval = FALSE, echo = FALSE}
stdize_column <- function(data, variable) {
  new_var <- data %>%
    mutate( {{ variable }} ) %>%
    standardize()
  return(new_var)
}

stdize_column(penguins, body_mass_g)
```

```{r, echo = FALSE}
decorate("tunnel", eval = FALSE) %>%
  flair("{{ variable }}")
```

---

.larger[What if I want to modify multiple columns?]

--

.large[Our friend `across()`!]



---

class: center, middle, inverse

.huge-text[Function Writing Tips]

---

.larger[Tip 1]

.bitlarger[**Keep thinking about object types and structures!!!**]

---

.larger[Tip 2]

.bitlarger[**If you want to write a function for data wrangling, consider
arguments that expect _vectors_ rather than _variable names_.**]
