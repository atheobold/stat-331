---
title: "Grading Guide - Lab 7"
output: html_document
---

## Report Formatting

**4**: The report has **all** the following, 

- Easy to locate headers / titles for question numbers
- No warnings from code
- No messages from code
- No output of data previews

**3**: The report has one of the following, 

- No headers / titles for question numbers 
- A preview of the data (e.g., `glimpse(avocado)`)

**Redo if above conditions are not met**

</br>

## Code Formatting 

**4**: Code formatting adheres to the tidyverse styling guide. At a bare
minimum, the code has the following:
  
  * spaces around `=` signs 
  * spaces after `,`s
  * new lines after `+`s
  * new lines after `%>%`s
  * no lines of code that wrap across multiple lines

**3**: No more than two occurrences of code formatting which does not adhere
to styling guide

**Redo if above conditions are not met**

---

## Part One: Summaries and Plots

### Task 1 

**4**: Outputs a table showing **only** the number of missing values for each 
variable in the dataset

**3**: Outputs more information than is necessary, but shows that weight is the 
only variable with missing values

**Redo**: If neither of the above conditions are met


```{r, eval = FALSE}
## Examples of 4

fish %>% 
  summarize(across(
    .cols = everything(), 
    .fns = ~sum(is.na(.) == TRUE)
    )
  ) 

colSums(is.na(fish))

## Example of 3

summary(fish)

```
 
</br>

### Task 2 

- Absolutely every answer must have:

  * grouped counts for the number of missing observations
  (`group_by()` + `count()` or `group_by()` + `summarize()`) 
  * barplot of counts (with `geom_bar()` or `geom_col()`)
  
If **any** of these are not met, the response earns a "Redo"


**4** -- Must have:
    + `fill` for one variable & `facet_wrap()` for the other variable
    + axis labels stating what is being plotted 
    + the values of the years must be legible (on y-axis or rotated)

**3** -- Must have: 
    + `fill` for one variable & `facet_wrap()` for the other variable
    + axis labels stating what is being plotted 

**Redo**: If neither of the above conditions are met


```{r, eval = FALSE}
## Example of a 4

fish %>% 
  filter(is.na(weight)) %>% 
  group_by(year, section, trip) %>% 
  count(is.na(weight)) %>% 
  mutate(trip = as.factor(trip), 
         year = as.factor(year)) %>% 
  ggplot(aes(y = year, x = n, fill = trip)) + 
  geom_col() + 
  facet_wrap(vars(section)) + 
  labs(y = "Sample Year", 
       x = "Number Missing", 
       fill = "Trip Number") +
  scale_fill_brewer(palette = "Paired")

## Example of a 3 

fish %>% 
  filter(is.na(weight)) %>% 
  group_by(year, section, trip) %>% 
  count(is.na(weight)) %>% 
  mutate(trip = as.factor(trip), 
         year = as.factor(year)) %>% 
  ggplot(aes(x = year, y = n, fill = trip)) + 
  geom_col() + 
  facet_wrap(vars(section)) + 
  labs(y = "Sample Year", 
       x = "Number Missing", 
       fill = "Trip Number") +
  scale_fill_brewer(palette = "Paired")

```

---

## Part Two:  Adjust the Data (Function Writing)

### Task 1

Let's transform the repeated process above into a `rescale()` function.  

- The function should take a single vector as its argument.

  * **4** -- Must have:
    + store `range()` in an object 
    + use object with `range()` elements (e.g. `range[1]`) to calculate scaled
    values
    + explicit return (e.g. `return(scaled)`)
    
  * **3**
    + If the `min()` function is called twice **or** if there is not an
    explicit return
    
  * **Redo** 
    + If the `min()` function is called twice **and** there is not an
    explicit return


```{r, eval = FALSE}
rescale <- function(x){
  rng <- range(x, na.rm = TRUE)
  scaled <-  (x - rng[1]) / (rng[2] - rng[1])
  return(scaled)
}
```


### Task 2

Now, let's incorporate some checks into your function! Modify your previous code
to create the following checks: 

- the function should stop if the input is not numeric
- the function should stop if the length of the vector is not greater than 1 

  * **4** -- Must have:
   + Conditional checks for whether an input is numeric (`is.numeric(x)`) 
   **and** if the vector's length is strictly greater than 1 (`length(x) > 1`)
   (Note if the checks allow for the function to be vectorized!)
  
  + **Redo** -- If one of the above checks is incorrect

```{r, eval = FALSE}
rescale <- function(x){
  stopifnot(is.numeric(x), 
            length(x) > 1)
  
  rng <- range(x, na.rm = TRUE)
  scaled <-  (x - rng[1]) / (rng[2] - rng[1])
  return(scaled)
}
```


### Task 3

Test your function on a simple vector. 

  - **4** -- If there is evidence of a check
  
  - **Redo** -- If there is not evidence of a check

```{r, eval = FALSE}

x <- c(1:25, NA)

rescale(x)

```

### Task 4

Next, let's test the function on the `length` column of the `BlackfootFish`
dataset.

- Make side-by-side plots of the original values of `length` and the rescaled
values of `length`. 

  * **4** -- Must have:
   +  two histograms of `length` variable (unscaled and scaled) 
   + different y-axis labels: (1) stating the units of the original measurements
   (mm), and (2) stating the values are scaled (e.g. "Scaled Fish Lengths")
   + side-by-side plots (either using `grid.arrange()` or code chunk specifications)
  
  * **3** -- If **one** of the following is true for the response
    + does not use `geom_histogram()`
    + does not change y-axis labels

  * **Redo** -- If the plots are not side-by-side **or** if both of the 
  statments above (for a **3**) are true 


```{r, eval = FALSE}

original <- fish %>% 
  ggplot(aes(x = length)) + 
  geom_histogram(binwidth = 45) + 
  labs(x = "Fish Length (mm)")

scaled <- fish %>% 
  mutate(length_scaled = rescale(length)) %>%  
  ggplot(aes(x = length_scaled)) + 
  geom_histogram(binwidth = .04) + 
  labs(x = "Scaled Fish Lengths (Scaled with Minimum and Range)")

grid.arrange(original, scaled, nrow = 1)

```


### Task 5 (incorrectly labeled as Task 4)

Use your `rescale()` function to rescale **both** the `length` and `weight` 
columns. **I expect that you only call the `rescale()` function _one_ time!**  

  - **4** -- If the response uses `mutate_at()` to scale the variables 
  - **Redo** -- If the response calls the `rescale()` function twices


```{r, eval = FALSE}
fish <- fish %>% 
  mutate_at(vars(length:weight), 
            rescale)
```