---
title: "Grading Guide - Lab 7"
output: html_document
---

## Report Formatting

**4**: The report has **all** the following, 

- Easy to locate headers / titles for question numbers
- No warnings from code
- No messages from code
- No output of data previews

**3**: The report has one of the following, 

- No headers / titles for question numbers 
- A preview of the data (e.g., `glimpse(avocado)`)

**Redo if above conditions are not met**

</br>

## Code Formatting 

**4**: Code formatting adheres to the tidyverse styling guide. At a bare
minimum, the code has the following:
  
  * spaces around `=` signs 
  * spaces after `,`s
  * new lines after `+`s
  * new lines after `%>%`s
  * no lines of code that wrap across multiple lines

**3**: No more than two occurrences of code formatting which does not adhere
to styling guide

**Redo if above conditions are not met**

---

## Part One: Summaries and Plots

### Task 1 

**4**: Outputs a table showing **only** the number of missing values for each 
variable in the dataset

**3**: Outputs more information than is necessary, but shows that weight is the 
only variable with missing values

**Redo**: If code calls same function multiple times
(instead of using `across()`)


```{r, eval = FALSE}
## Examples of 4

fish %>% 
  summarize(across(
    .cols = everything(), 
    .fns = ~sum(is.na(.) == TRUE)
    )
  ) 

colSums(is.na(fish))

## Example of 3

summary(fish)

```
 
</br>

### Task 2 

- Absolutely every answer must have:

  * grouped counts for the number of missing observations
  (`group_by()` + `count()` or `group_by()` + `summarize()`) 
  **OR** 
  * `filter()` data to include *only* observations with missing weight
  
  * barplot of counts (with `geom_bar()` or `geom_col()`)
  
If **any** of these are not met, the response earns a "Redo"

**4** -- Must have:

- `fill` for either `trip` or `section` & `facet_wrap()` for the other variable
- axis labels stating what is being plotted 
- the values of the years must be legible (on y-axis or at an angle on x-axis)
- counts are plotted on x- or y-axis

**3** -- Must have: 

- `fill` for either `trip` or `section` & `facet_wrap()` for the other variable
- axis labels stating what is being plotted 
- counts are plotted on x- or y-axis

**Redo**: If neither of the above conditions are met


```{r, eval = FALSE}
## Example of a 4

fish %>% 
  filter(is.na(weight)) %>% 
  group_by(year, section, trip) %>% 
  count(is.na(weight)) %>% 
  mutate(trip = as.factor(trip), 
         year = as.factor(year)) %>% 
  ggplot(aes(y = year, x = n, fill = trip)) + 
  geom_col() + 
  facet_wrap(vars(section)) + 
  labs(y = "Sample Year", 
       x = "Number Missing", 
       fill = "Trip Number") +
  scale_fill_brewer(palette = "Paired")

## Example of a 3 

fish %>% 
  filter(is.na(weight)) %>% 
  group_by(year, section, trip) %>% 
  count(is.na(weight)) %>% 
  mutate(trip = as.factor(trip), 
         year = as.factor(year)) %>% 
  ggplot(aes(x = year, y = n, fill = trip)) + 
  geom_col() + 
  facet_wrap(vars(section)) + 
  labs(y = "Sample Year", 
       x = "Number Missing", 
       fill = "Trip Number") +
  scale_fill_brewer(palette = "Paired")

```

---

## Part Two:  Adjust the Data (Function Writing)

### Task 1

To return the scaled vector, the function can either, (1) use a `return()` 
statement, or (2) output the result

**4** -- Must have:

- store `range()` in an object 
- use object (e.g. `rng[1]`) to calculate scaled values

**3**: 

- `min()` function is called once and saved to an object
- (optional) `max()` function is called and saved into an object

**Redo**: If the `min()` function is called twice


```{r, eval = FALSE}
# Example of 4s
rescale <- function(x){
  rng <- range(x, na.rm = TRUE)
  scaled <-  (x - rng[1]) / (rng[2] - rng[1])
  return(scaled)
}

rescale <- function(x){
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

## Example of 3
rescale <- function(x){
  min <- min(x, na.rm = TRUE)
  scaled <-  (x - min) / (max(x, na.rm = TRUE) - min)
  return(scaled)
}

```


### Task 2

**4** -- Must have:

- `stopifnot(is.numeric(<input>))` to check if the input is numeric
- `stopifnot(length(<input>) > 1)` to check if the input is greater than 1 

**3.5**: If `stopifnot()` is called *twice*, once for each check. 

**3** -- Implements the above checks using `if()` statements rather than 
`stopifnot()` statements

**Redo**: If none of the above conditions are met

```{r, eval = FALSE}
rescale_01 <- function(x){
  stopifnot(is.numeric(x), 
            length(x) > 1)
  
  rng <- range(x, na.rm = TRUE)
  scaled <-  (x - rng[1]) / (rng[2] - rng[1])
  return(scaled)
}
```


### Task 3

Test your function on a simple vector. 

**4** -- Must have:

  - Uses `rescale_01()` function on example vector provided (`x <- c(1:25, NA)`)
  - Uses `min()` to verify the min of the output is 0
  - Uses `max()` to verify the max of the output is 1

**3** -- Does not call `min()` or `max()` explicitly but confirms minimum and 
maximum

**Redo** -- If there is not evidence of a check

```{r, eval = FALSE}

x <- c(1:25, NA)

rescaled <- rescale_01(x)
min(rescaled)
max(rescaled)
```

### Task 4

**4** -- Must have:

- Two plots of any of the following types: `geom_histogram()`,
`geom_density()`, or `geom_boxplot()`

- Different axis labels stating which plot has the original measurements (in mm)
and which plot has the scaled values

- Side-by-side plots, stacked horizontally *not* vertically

**Redo**: If the above conditions are met

```{r, eval = FALSE}
original <- fish %>% 
  ggplot(aes(x = length)) + 
  geom_histogram(binwidth = 45) +
  labs(x = "Original Values of Fish Length (mm)")

scaled <- fish %>% 
  mutate(length_scaled = rescale_01(length)) %>%  
  ggplot(aes(x = length_scaled)) + 
  geom_histogram(binwidth = .04) + 
  labs(x = "Rescaled Values of Fish Length")


grid.arrange(original, scaled, nrow = 1)
```


### Task 5

**4** -- Must have the following: 

  - **Two** inputs: the data, the variables to modify (as one input)
  - Check to verify data input is a `data.frame`
  - Uses `mutate()` to modify the variables
  - Uses `across()` and injection (`{{ }}`) to access variables to modify
  - Uses existing `rescale_01()` function to modify variables
  - Outputs the rescaled data

**3** -- If all of the above conditions are met *except* for the dataframe 
check

**Redo** -- If the above conditions are not met

```{r, eval = FALSE}
rescale_column <- function(data, variables){
  stopifnot(is.data.frame(data))
  
  data %>% 
    mutate(
      across(.cols = {{ variables }}, 
             .fns = rescale_01)
    )
}
```

### Task 6

**4** -- Must have the following:

- Calls `rescale_column()` function
- Inputs `fish` data
- Inputs `length` and `weight` columns (in one argument)
- Outputs rescaled data (as preview or as raw output)

**Redo** -- If the above conditions are not met

```{r, eval = FALSE}
rescale_column(fish, length:weight)
```